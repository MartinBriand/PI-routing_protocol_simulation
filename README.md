# PI-routing_protocol_simulation

> Important: Please read the `CONTRIBUTING.md` file to know how to contribute to the project

## Introduction
### Why the project
The aim is to propose a protocol that optimize the stochastic price to send a good from one place to another over the _PI_

### The protocol
When a good arrives at a node (because of being generated by a shipper or carried from another node by a carrier), the load is immediately auctioned to get the best price and decide of the next node. Do do so, we designed an auction in which the decision of the next node is incentivized by node weights (carefully designed to optimize the stochastic price of the remaining route), and the price paid to get to the next hop is the result of a bid competition between carriers. Due to the non continuous time of the informatic simulation, little adaptation are made to handle the case of having multiple load auctioned at the same time at one specific node.

### The auction
Supposing that the weights are given (see next subsubsection), the carriers submit a bid for each next node, their bid is incremented by the weight of each corresponding next node according to the current node running the auction. The winner is the (carrier, next_node) combination with the minimum transformed bid. The price paid is the first transformed bid of another carrier (or the reserve price of the shipper if need be) minus the weight of the next node.

Such an auction can be proved to have all the good properties of incentive and budget whished for a one time auction. However, in a repeated game environment, the analysis is much more complicated (hence the simulation)

### The design of the weights
The weights are designed such that they stochastically optimize a cost function. However, the learning rate of the weight is a real question to avoid being stuck in a suboptimal position.

## The objects and their philosophy
We have objects separated in two categories:
* the `actors` can make strategic decisions:
  * `carriers` transport the goods. They can:
    * bid
    * decide to go to another node if not carrying a load
  * `nodes` to run the auction. They can:
    * Decide of the weights
    * Decide of the price to charge the carrier for each auction
  * `shipper` to emit loads. They can:
    * decide of a reserve price at each node
* The `tools` are not going to change:
  * the `auctions` are run by `nodes`, they make load attribution and ask for payments
  * the `loads` are generated by `shippers`
* At last, we have an `environment` that owns all the objects, this is a sort of timer to make the model run on a computer. In reality, such an object should not exist

Then experiments can be designed and run using these objects in `Games` scripts

## The Data flow and the workflow
In the whole project, the data flow is such that the parent object call for the creation of the child object (the only exception being the `environment` which doesn't call for the creation of anything), and then the object signals it presence or state to the parent object (there is no exception to this rule). This make the mechanism highly readable and easy to debug. I highly recomend to follow this workflow for further development.

Also, none of the attribute of an object are transformed by other object, the other object always call a function asking the specific object to change its property. (Again, respecting the dataflow describe above).

## Launching a game
A game is launched in the `Games` folder. It sript instaciating all the objects (`environment` and `actors`) and running a loop to run the `Environment.iter` method.
